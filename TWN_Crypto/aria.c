#include "aria.h"


byte s_box1[256] = { 0x63 ,0x7c ,0x77 ,0x7b ,0xf2 ,0x6b ,0x6f ,0xc5 ,0x30 ,0x01 ,0x67 ,0x2b ,0xfe ,0xd7 ,0xab ,0x76
 ,0xca ,0x82 ,0xc9 ,0x7d ,0xfa ,0x59 ,0x47 ,0xf0 ,0xad ,0xd4 ,0xa2 ,0xaf ,0x9c ,0xa4 ,0x72 ,0xc0
 ,0xb7 ,0xfd ,0x93 ,0x26 ,0x36 ,0x3f ,0xf7 ,0xcc ,0x34 ,0xa5 ,0xe5 ,0xf1 ,0x71 ,0xd8 ,0x31 ,0x15
 ,0x04 ,0xc7 ,0x23 ,0xc3 ,0x18 ,0x96 ,0x05 ,0x9a ,0x07 ,0x12 ,0x80 ,0xe2 ,0xeb ,0x27 ,0xb2 ,0x75
 ,0x09 ,0x83 ,0x2c ,0x1a ,0x1b ,0x6e ,0x5a ,0xa0 ,0x52 ,0x3b ,0xd6 ,0xb3 ,0x29 ,0xe3 ,0x2f ,0x84
 ,0x53 ,0xd1 ,0x00 ,0xed ,0x20 ,0xfc ,0xb1 ,0x5b ,0x6a ,0xcb ,0xbe ,0x39 ,0x4a ,0x4c ,0x58 ,0xcf
 ,0xd0 ,0xef ,0xaa ,0xfb ,0x43 ,0x4d ,0x33 ,0x85 ,0x45 ,0xf9 ,0x02 ,0x7f ,0x50 ,0x3c ,0x9f ,0xa8
 ,0x51 ,0xa3 ,0x40 ,0x8f ,0x92 ,0x9d ,0x38 ,0xf5 ,0xbc ,0xb6 ,0xda ,0x21 ,0x10 ,0xff ,0xf3 ,0xd2
 ,0xcd ,0x0c ,0x13 ,0xec ,0x5f ,0x97 ,0x44 ,0x17 ,0xc4 ,0xa7 ,0x7e ,0x3d ,0x64 ,0x5d ,0x19 ,0x73
 ,0x60 ,0x81 ,0x4f ,0xdc ,0x22 ,0x2a ,0x90 ,0x88 ,0x46 ,0xee ,0xb8 ,0x14 ,0xde ,0x5e ,0x0b ,0xdb
 ,0xe0 ,0x32 ,0x3a ,0x0a ,0x49 ,0x06 ,0x24 ,0x5c ,0xc2 ,0xd3 ,0xac ,0x62 ,0x91 ,0x95 ,0xe4 ,0x79
 ,0xe7 ,0xc8 ,0x37 ,0x6d ,0x8d ,0xd5 ,0x4e ,0xa9 ,0x6c ,0x56 ,0xf4 ,0xea ,0x65 ,0x7a ,0xae ,0x08
 ,0xba ,0x78 ,0x25 ,0x2e ,0x1c ,0xa6 ,0xb4 ,0xc6 ,0xe8 ,0xdd ,0x74 ,0x1f ,0x4b ,0xbd ,0x8b ,0x8a
 ,0x70 ,0x3e ,0xb5 ,0x66 ,0x48 ,0x03 ,0xf6 ,0x0e ,0x61 ,0x35 ,0x57 ,0xb9 ,0x86 ,0xc1 ,0x1d ,0x9e
 ,0xe1 ,0xf8 ,0x98 ,0x11 ,0x69 ,0xd9 ,0x8e ,0x94 ,0x9b ,0x1e ,0x87 ,0xe9 ,0xce ,0x55 ,0x28 ,0xdf
 ,0x8c ,0xa1 ,0x89 ,0x0d ,0xbf ,0xe6 ,0x42 ,0x68 ,0x41 ,0x99 ,0x2d ,0x0f ,0xb0 ,0x54 ,0xbb ,0x16 };


byte inv_s_box1[256] = { 0x52 ,0x09 ,0x6a ,0xd5 ,0x30 ,0x36 ,0xa5 ,0x38 ,0xbf ,0x40 ,0xa3 ,0x9e ,0x81 ,0xf3 ,0xd7 ,0xfb
 ,0x7c ,0xe3 ,0x39 ,0x82 ,0x9b ,0x2f ,0xff ,0x87 ,0x34 ,0x8e ,0x43 ,0x44 ,0xc4 ,0xde ,0xe9 ,0xcb
 ,0x54 ,0x7b ,0x94 ,0x32 ,0xa6 ,0xc2 ,0x23 ,0x3d ,0xee ,0x4c ,0x95 ,0x0b ,0x42 ,0xfa ,0xc3 ,0x4e
 ,0x08 ,0x2e ,0xa1 ,0x66 ,0x28 ,0xd9 ,0x24 ,0xb2 ,0x76 ,0x5b ,0xa2 ,0x49 ,0x6d ,0x8b ,0xd1 ,0x25
 ,0x72 ,0xf8 ,0xf6 ,0x64 ,0x86 ,0x68 ,0x98 ,0x16 ,0xd4 ,0xa4 ,0x5c ,0xcc ,0x5d ,0x65 ,0xb6 ,0x92
 ,0x6c ,0x70 ,0x48 ,0x50 ,0xfd ,0xed ,0xb9 ,0xda ,0x5e ,0x15 ,0x46 ,0x57 ,0xa7 ,0x8d ,0x9d ,0x84
 ,0x90 ,0xd8 ,0xab ,0x00 ,0x8c ,0xbc ,0xd3 ,0x0a ,0xf7 ,0xe4 ,0x58 ,0x05 ,0xb8 ,0xb3 ,0x45 ,0x06
 ,0xd0 ,0x2c ,0x1e ,0x8f ,0xca ,0x3f ,0x0f ,0x02 ,0xc1 ,0xaf ,0xbd ,0x03 ,0x01 ,0x13 ,0x8a ,0x6b
 ,0x3a ,0x91 ,0x11 ,0x41 ,0x4f ,0x67 ,0xdc ,0xea ,0x97 ,0xf2 ,0xcf ,0xce ,0xf0 ,0xb4 ,0xe6 ,0x73
 ,0x96 ,0xac ,0x74 ,0x22 ,0xe7 ,0xad ,0x35 ,0x85 ,0xe2 ,0xf9 ,0x37 ,0xe8 ,0x1c ,0x75 ,0xdf ,0x6e
 ,0x47 ,0xf1 ,0x1a ,0x71 ,0x1d ,0x29 ,0xc5 ,0x89 ,0x6f ,0xb7 ,0x62 ,0x0e ,0xaa ,0x18 ,0xbe ,0x1b
 ,0xfc ,0x56 ,0x3e ,0x4b ,0xc6 ,0xd2 ,0x79 ,0x20 ,0x9a ,0xdb ,0xc0 ,0xfe, 0x78 ,0xcd ,0x5a ,0xf4
 ,0x1f ,0xdd ,0xa8 ,0x33 ,0x88 ,0x07 ,0xc7 ,0x31 ,0xb1 ,0x12 ,0x10 ,0x59 ,0x27 ,0x80 ,0xec ,0x5f
 ,0x60 ,0x51 ,0x7f ,0xa9 ,0x19 ,0xb5 ,0x4a ,0x0d ,0x2d ,0xe5 ,0x7a ,0x9f ,0x93 ,0xc9 ,0x9c ,0xef
 ,0xa0 ,0xe0 ,0x3b ,0x4d ,0xae ,0x2a ,0xf5 ,0xb0 ,0xc8 ,0xeb ,0xbb ,0x3c ,0x83 ,0x53 ,0x99 ,0x61
 ,0x17 ,0x2b ,0x04 ,0x7e ,0xba ,0x77 ,0xd6 ,0x26 ,0xe1 ,0x69 ,0x14 ,0x63 ,0x55 ,0x21 ,0x0c ,0x7d };

byte s_box2[256] = { 0xe2 ,0x4e ,0x54 ,0xfc ,0x94 ,0xc2 ,0x4a ,0xcc ,0x62 ,0x0d ,0x6a ,0x46 ,0x3c ,0x4d ,0x8b ,0xd1
,0x5e ,0xfa ,0x64 ,0xcb ,0xb4 ,0x97 ,0xbe ,0x2b ,0xbc ,0x77 ,0x2e ,0x03 ,0xd3 ,0x19 ,0x59 ,0xc1
,0x1d ,0x06 ,0x41 ,0x6b ,0x55 ,0xf0 ,0x99 ,0x69 ,0xea ,0x9c ,0x18 ,0xae ,0x63 ,0xdf ,0xe7 ,0xbb
,0x00 ,0x73 ,0x66 ,0xfb ,0x96 ,0x4c ,0x85 ,0xe4 ,0x3a ,0x09 ,0x45 ,0xaa ,0x0f ,0xee ,0x10 ,0xeb
,0x2d ,0x7f ,0xf4 ,0x29 ,0xac ,0xcf ,0xad ,0x91 ,0x8d ,0x78 ,0xc8 ,0x95 ,0xf9 ,0x2f ,0xce ,0xcd
,0x08 ,0x7a ,0x88 ,0x38 ,0x5c ,0x83 ,0x2a ,0x28 ,0x47 ,0xdb ,0xb8 ,0xc7 ,0x93 ,0xa4 ,0x12 ,0x53
,0xff ,0x87 ,0x0e ,0x31 ,0x36 ,0x21 ,0x58 ,0x48 ,0x01 ,0x8e ,0x37 ,0x74 ,0x32 ,0xca ,0xe9 ,0xb1
,0xb7 ,0xab ,0x0c ,0xd7 ,0xc4 ,0x56 ,0x42 ,0x26 ,0x07 ,0x98 ,0x60 ,0xd9 ,0xb6 ,0xb9 ,0x11 ,0x40
,0xec ,0x20 ,0x8c ,0xbd ,0xa0 ,0xc9 ,0x84 ,0x04 ,0x49 ,0x23 ,0xf1 ,0x4f ,0x50 ,0x1f ,0x13 ,0xdc
,0xd8 ,0xc0 ,0x9e ,0x57 ,0xe3 ,0xc3 ,0x7b ,0x65 ,0x3b ,0x02 ,0x8f ,0x3e ,0xe8 ,0x25 ,0x92 ,0xe5
,0x15 ,0xdd ,0xfd ,0x17 ,0xa9 ,0xbf ,0xd4 ,0x9a ,0x7e ,0xc5 ,0x39 ,0x67 ,0xfe ,0x76 ,0x9d ,0x43
,0xa7 ,0xe1 ,0xd0 ,0xf5 ,0x68 ,0xf2 ,0x1b ,0x34 ,0x70 ,0x05 ,0xa3 ,0x8a ,0xd5 ,0x79 ,0x86 ,0xa8
,0x30 ,0xc6 ,0x51 ,0x4b ,0x1e ,0xa6 ,0x27 ,0xf6 ,0x35 ,0xd2 ,0x6e ,0x24 ,0x16 ,0x82 ,0x5f ,0xda
,0xe6 ,0x75 ,0xa2 ,0xef ,0x2c ,0xb2 ,0x1c ,0x9f ,0x5d ,0x6f ,0x80 ,0x0a ,0x72 ,0x44 ,0x9b ,0x6c
,0x90 ,0x0b ,0x5b ,0x33 ,0x7d ,0x5a ,0x52 ,0xf3 ,0x61 ,0xa1 ,0xf7 ,0xb0 ,0xd6 ,0x3f ,0x7c ,0x6d
,0xed ,0x14 ,0xe0 ,0xa5 ,0x3d ,0x22 ,0xb3 ,0xf8 ,0x89 ,0xde ,0x71 ,0x1a ,0xaf ,0xba ,0xb5 ,0x81 };

byte inv_s_box2[256] = { 0x30 ,0x68 ,0x99 ,0x1b ,0x87 ,0xb9 ,0x21 ,0x78 ,0x50 ,0x39 ,0xdb ,0xe1 ,0x72 ,0x09 ,0x62 ,0x3c
,0x3e ,0x7e ,0x5e ,0x8e ,0xf1 ,0xa0 ,0xcc ,0xa3 ,0x2a ,0x1d ,0xfb ,0xb6 ,0xd6 ,0x20 ,0xc4 ,0x8d
,0x81 ,0x65 ,0xf5 ,0x89 ,0xcb ,0x9d ,0x77 ,0xc6 ,0x57 ,0x43 ,0x56 ,0x17 ,0xd4 ,0x40 ,0x1a ,0x4d
,0xc0 ,0x63 ,0x6c ,0xe3 ,0xb7 ,0xc8 ,0x64 ,0x6a ,0x53 ,0xaa ,0x38 ,0x98 ,0x0c ,0xf4 ,0x9b ,0xed
,0x7f ,0x22 ,0x76 ,0xaf ,0xdd ,0x3a ,0x0b ,0x58 ,0x67 ,0x88 ,0x06 ,0xc3 ,0x35 ,0x0d ,0x01 ,0x8b
,0x8c ,0xc2 ,0xe6 ,0x5f ,0x02 ,0x24 ,0x75 ,0x93 ,0x66 ,0x1e ,0xe5 ,0xe2 ,0x54 ,0xd8 ,0x10 ,0xce
,0x7a ,0xe8 ,0x08 ,0x2c ,0x12 ,0x97 ,0x32 ,0xab ,0xb4 ,0x27 ,0x0a ,0x23 ,0xdf ,0xef ,0xca ,0xd9
,0xb8 ,0xfa ,0xdc ,0x31 ,0x6b ,0xd1 ,0xad ,0x19 ,0x49 ,0xbd ,0x51 ,0x96 ,0xee ,0xe4 ,0xa8 ,0x41
,0xda ,0xff ,0xcd ,0x55 ,0x86 ,0x36 ,0xbe ,0x61 ,0x52 ,0xf8 ,0xbb ,0x0e ,0x82 ,0x48 ,0x69 ,0x9a
,0xe0 ,0x47 ,0x9e ,0x5c ,0x04 ,0x4b ,0x34 ,0x15 ,0x79 ,0x26 ,0xa7 ,0xde ,0x29 ,0xae ,0x92 ,0xd7
,0x84 ,0xe9 ,0xd2 ,0xba ,0x5d ,0xf3 ,0xc5 ,0xb0 ,0xbf ,0xa4 ,0x3b ,0x71 ,0x44 ,0x46 ,0x2b ,0xfc
,0xeb ,0x6f ,0xd5 ,0xf6 ,0x14 ,0xfe ,0x7c ,0x70 ,0x5a ,0x7d ,0xfd ,0x2f ,0x18 ,0x83 ,0x16 ,0xa5
,0x91 ,0x1f ,0x05 ,0x95 ,0x74 ,0xa9 ,0xc1 ,0x5b ,0x4a ,0x85 ,0x6d ,0x13 ,0x07 ,0x4f ,0x4e ,0x45
,0xb2 ,0x0f ,0xc9 ,0x1c ,0xa6 ,0xbc ,0xec ,0x73 ,0x90 ,0x7b ,0xcf ,0x59 ,0x8f ,0xa1 ,0xf9 ,0x2d
,0xf2 ,0xb1 ,0x00 ,0x94 ,0x37 ,0x9f ,0xd0 ,0x2e ,0x9c ,0x6e ,0x28 ,0x3f ,0x80 ,0xf0 ,0x3d ,0xd3
,0x25 ,0x8a ,0xb5 ,0xe7 ,0x42 ,0xb3 ,0xc7 ,0xea ,0xf7 ,0x4c ,0x11 ,0x33 ,0x03 ,0xa2 ,0xac ,0x60
};

void left_shift(byte* x, int l) {
	int k = 0;
	int r = 0;
	int i = 0;

	k = l / 8;
	r = l % 8;

	if (r == 0) {

		for (i = 0; i + k < 16; i++)
			x[i] = x[i + k];
		for (int j = i; j < 16; j++)
			x[j] = 0x00;
	}
	else {
		for (i = 0; i + k < 15; i++)
			x[i] = (x[i + k] << r) ^ (x[i + 1 + k] >> (8 - r));
		x[i] = x[i + k] << r;
		for (int j = i + 1; j < 16; j++)
			x[j] = 0x00;
	}
}

void right_shift(byte* x, int l) {
	int k = 0;
	int r = 0;
	int i = 0;

	k = l / 8;
	r = l % 8;
	byte tmp[16] = { 0x00 };
	memcpy(tmp, x, 16);
	byte ttmp = tmp[0];

	if (r == 0) {
		for (i = 0; i + k < 16; i++)
			x[i + k] = tmp[i];
		for (int j = 0; j < k; j++)
			x[j] = 0x00;
	}
	else {
		for (int j = 0; j < k; j++)
			x[j] = 0x00;
		x[k] = ttmp >> r;
		for (i = 1; i + k < 16; i++)
			x[i + k] = (tmp[i - 1] << (8 - r)) ^ (tmp[i] >> r);


	}
}



void ROR(byte* x, int r) {
	byte tmp[16];
	int k = 0;
	k = 128 - r;
	memcpy(tmp, x, 16);

	right_shift(x, r);
	left_shift(tmp, k);
	for (int i = 0; i < 16; i++)
		x[i] ^= tmp[i];
}

void ROL(byte* x, int r) {
	byte tmp[16];
	int k = 0;
	k = 128 - r;
	memcpy(tmp, x, 16);

	right_shift(tmp, k);
	left_shift(x, r);
	for (int i = 0; i < 16; i++)
		x[i] ^= tmp[i];
}

void Add_Round_Key(byte* state, byte* w) {
	for (int i = 0; i < 16; i++)
		state[i] ^= w[i];
}
void LT(byte* state) {

	state[0] = s_box1[state[0]];
	state[1] = s_box2[state[1]];
	state[2] = inv_s_box1[state[2]];
	state[3] = inv_s_box2[state[3]];
}

void inv_LT(byte* state) {

	state[0] = inv_s_box1[state[0]];
	state[1] = inv_s_box2[state[1]];
	state[2] = s_box1[state[2]];
	state[3] = s_box2[state[3]];
}

void SubstLayer(byte* state, int eo) {
	if (eo == 2) {
		byte t1[4], t2[4], t3[4], t4[4];
		memcpy(t1, state, 4);
		memcpy(t2, state + 4, 4);
		memcpy(t3, state + 8, 4);
		memcpy(t4, state + 12, 4);
		LT(t1);
		LT(t2);
		LT(t3);
		LT(t4);
		memcpy(state, t1, 4);
		memcpy(state + 4, t2, 4);
		memcpy(state + 8, t3, 4);
		memcpy(state + 12, t4, 4);
	}
	if (eo == 1) {
		byte t1[4], t2[4], t3[4], t4[4];
		memcpy(t1, state, 4);
		memcpy(t2, state + 4, 4);
		memcpy(t3, state + 8, 4);
		memcpy(t4, state + 12, 4);
		inv_LT(t1);
		inv_LT(t2);
		inv_LT(t3);
		inv_LT(t4);
		memcpy(state, t1, 4);
		memcpy(state + 4, t2, 4);
		memcpy(state + 8, t3, 4);
		memcpy(state + 12, t4, 4);
	}
}

void DiffLayer(byte* state) {
	byte tmp[16] = { 0x00, };
	memcpy(tmp, state, 16);

	state[0] = tmp[3] ^ tmp[4] ^ tmp[6] ^ tmp[8] ^ tmp[9] ^ tmp[13] ^ tmp[14];
	state[1] = tmp[2] ^ tmp[5] ^ tmp[7] ^ tmp[8] ^ tmp[9] ^ tmp[12] ^ tmp[15];
	state[2] = tmp[1] ^ tmp[4] ^ tmp[6] ^ tmp[10] ^ tmp[11] ^ tmp[12] ^ tmp[15];
	state[3] = tmp[0] ^ tmp[5] ^ tmp[7] ^ tmp[10] ^ tmp[11] ^ tmp[13] ^ tmp[14];
	state[4] = tmp[0] ^ tmp[2] ^ tmp[5] ^ tmp[8] ^ tmp[11] ^ tmp[14] ^ tmp[15];
	state[5] = tmp[1] ^ tmp[3] ^ tmp[4] ^ tmp[9] ^ tmp[10] ^ tmp[14] ^ tmp[15];
	state[6] = tmp[0] ^ tmp[2] ^ tmp[7] ^ tmp[9] ^ tmp[10] ^ tmp[12] ^ tmp[13];
	state[7] = tmp[1] ^ tmp[3] ^ tmp[6] ^ tmp[8] ^ tmp[11] ^ tmp[12] ^ tmp[13];
	state[8] = tmp[0] ^ tmp[1] ^ tmp[4] ^ tmp[7] ^ tmp[10] ^ tmp[13] ^ tmp[15];
	state[9] = tmp[0] ^ tmp[1] ^ tmp[5] ^ tmp[6] ^ tmp[11] ^ tmp[12] ^ tmp[14];
	state[10] = tmp[2] ^ tmp[3] ^ tmp[5] ^ tmp[6] ^ tmp[8] ^ tmp[13] ^ tmp[15];
	state[11] = tmp[2] ^ tmp[3] ^ tmp[4] ^ tmp[7] ^ tmp[9] ^ tmp[12] ^ tmp[14];
	state[12] = tmp[1] ^ tmp[2] ^ tmp[6] ^ tmp[7] ^ tmp[9] ^ tmp[11] ^ tmp[12];
	state[13] = tmp[0] ^ tmp[3] ^ tmp[6] ^ tmp[7] ^ tmp[8] ^ tmp[10] ^ tmp[13];
	state[14] = tmp[0] ^ tmp[3] ^ tmp[4] ^ tmp[5] ^ tmp[9] ^ tmp[11] ^ tmp[14];
	state[15] = tmp[1] ^ tmp[2] ^ tmp[4] ^ tmp[5] ^ tmp[8] ^ tmp[10] ^ tmp[15];
}

void F_o(byte* state, byte* k) {
	Add_Round_Key(state, k);
	SubstLayer(state, 2);
	DiffLayer(state);
}

void F_e(byte* state, byte* k) {
	Add_Round_Key(state, k);
	SubstLayer(state, 1);
	DiffLayer(state);
}

void Key_expansion(byte* w, byte* key, unsigned int keyLen) {
	byte W0[16] = { 0x00 };
	byte W1[16] = { 0x00 };
	byte W2[16] = { 0x00 };
	byte W3[16] = { 0x00 };
	byte tmp[16] = { 0x00 };

	if (keyLen == 16) {
		byte KL[16] = { 0x00 ,0x01 ,0x02 ,0x03 ,0x04 ,0x05 ,0x06 ,0x07 ,0x08 ,0x09 ,0x0a ,0x0b ,0x0c ,0x0d ,0x0e, 0x0f };
		byte KR[16] = { 0x00, };
		byte ck1[16] = { 0x51, 0x7c, 0xc1, 0xb7, 0x27, 0x22, 0x0a, 0x94, 0xfe, 0x13, 0xab, 0xe8, 0xfa, 0x9a, 0x6e, 0xe0 };
		byte ck2[16] = { 0x6d, 0xb1, 0x4a, 0xcc, 0x9e, 0x21, 0xc8, 0x20, 0xff, 0x28, 0xb1, 0xd5, 0xef, 0x5d, 0xe2, 0xb0 };
		byte ck3[16] = { 0xdb, 0x92, 0x37, 0x1d, 0x21, 0x26, 0xe9, 0x70, 0x03, 0x24, 0x97, 0x75, 0x04, 0xe8, 0xc9, 0x0e };

		memcpy(W0, KL, 16);
		memcpy(tmp, W0, 16);
		F_o(tmp, ck1);
		for (int i = 0; i < 16; i++)
			W1[i] = tmp[i] ^ KR[i];
		memcpy(tmp, W1, 16);
		F_e(tmp, ck2);
		for (int i = 0; i < 16; i++)
			W2[i] = tmp[i] ^ W0[i];
		memcpy(tmp, W2, 16);
		F_o(tmp, ck3);
		for (int i = 0; i < 16; i++)
			W3[i] = tmp[i] ^ W1[i];

		ROR(W1, 19);
		for (int i = 0; i < 16; i++)
			w[i] = W0[i] ^ W1[i];
		ROL(W1, 19);

		ROR(W2, 19);
		for (int i = 0; i < 16; i++)
			w[i + 16] = W1[i] ^ W2[i];
		ROL(W2, 19);

		ROR(W3, 19);
		for (int i = 0; i < 16; i++)
			w[i + 32] = W2[i] ^ W3[i];
		ROL(W3, 19);

		ROR(W0, 19);
		for (int i = 0; i < 16; i++)
			w[i + 48] = W0[i] ^ W3[i];
		ROL(W0, 19);

		ROR(W1, 31);
		for (int i = 0; i < 16; i++)
			w[i + 64] = W0[i] ^ W1[i];
		ROL(W1, 31);

		ROR(W2, 31);
		for (int i = 0; i < 16; i++)
			w[i + 80] = W1[i] ^ W2[i];
		ROL(W2, 31);

		ROR(W3, 31);
		for (int i = 0; i < 16; i++)
			w[i + 96] = W2[i] ^ W3[i];
		ROL(W3, 31);

		ROR(W0, 31);
		for (int i = 0; i < 16; i++)
			w[i + 112] = W0[i] ^ W3[i];
		ROL(W0, 31);

		ROL(W1, 61);
		for (int i = 0; i < 16; i++)
			w[i + 128] = W0[i] ^ W1[i];
		ROR(W1, 61);

		ROL(W2, 61);
		for (int i = 0; i < 16; i++)
			w[i + 144] = W1[i] ^ W2[i];
		ROR(W2, 61);

		ROL(W3, 61);
		for (int i = 0; i < 16; i++)
			w[i + 160] = W2[i] ^ W3[i];
		ROR(W3, 61);

		ROL(W0, 61);
		for (int i = 0; i < 16; i++)
			w[i + 176] = W0[i] ^ W3[i];
		ROR(W0, 61);

		ROL(W1, 31);
		for (int i = 0; i < 16; i++)
			w[i + 192] = W0[i] ^ W1[i];
		ROR(W1, 31);


	}
	else if (keyLen == 24) {
		byte KL[16] = { 0x00 ,0x01 ,0x02 ,0x03 ,0x04 ,0x05 ,0x06 ,0x07 ,0x08 ,0x09 ,0x0a ,0x0b ,0x0c ,0x0d ,0x0e, 0x0f };
		byte KR[16] = { 0x10 ,0x11 ,0x12 ,0x13 ,0x14 ,0x15 ,0x16 ,0x17 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00, 0x00 };
		byte ck1[16] = { 0x6d, 0xb1, 0x4a, 0xcc, 0x9e, 0x21, 0xc8, 0x20, 0xff, 0x28, 0xb1, 0xd5, 0xef, 0x5d, 0xe2, 0xb0 };
		byte ck2[16] = { 0xdb, 0x92, 0x37, 0x1d, 0x21, 0x26, 0xe9, 0x70, 0x03, 0x24, 0x97, 0x75, 0x04, 0xe8, 0xc9, 0x0e };
		byte ck3[16] = { 0x51, 0x7c, 0xc1, 0xb7, 0x27, 0x22, 0x0a, 0x94, 0xfe, 0x13, 0xab, 0xe8, 0xfa, 0x9a, 0x6e, 0xe0 };
		memcpy(W0, KL, 16);
		memcpy(tmp, W0, 16);
		F_o(tmp, ck1);
		for (int i = 0; i < 16; i++)
			W1[i] = tmp[i] ^ KR[i];
		memcpy(tmp, W1, 16);
		F_e(tmp, ck2);
		for (int i = 0; i < 16; i++)
			W2[i] = tmp[i] ^ W0[i];
		memcpy(tmp, W2, 16);
		F_o(tmp, ck3);
		for (int i = 0; i < 16; i++)
			W3[i] = tmp[i] ^ W1[i];

		ROR(W1, 19);
		for (int i = 0; i < 16; i++)
			w[i] = W0[i] ^ W1[i];
		ROL(W1, 19);

		ROR(W2, 19);
		for (int i = 0; i < 16; i++)
			w[i + 16] = W1[i] ^ W2[i];
		ROL(W2, 19);

		ROR(W3, 19);
		for (int i = 0; i < 16; i++)
			w[i + 32] = W2[i] ^ W3[i];
		ROL(W3, 19);

		ROR(W0, 19);
		for (int i = 0; i < 16; i++)
			w[i + 48] = W0[i] ^ W3[i];
		ROL(W0, 19);

		ROR(W1, 31);
		for (int i = 0; i < 16; i++)
			w[i + 64] = W0[i] ^ W1[i];
		ROL(W1, 31);

		ROR(W2, 31);
		for (int i = 0; i < 16; i++)
			w[i + 80] = W1[i] ^ W2[i];
		ROL(W2, 31);

		ROR(W3, 31);
		for (int i = 0; i < 16; i++)
			w[i + 96] = W2[i] ^ W3[i];
		ROL(W3, 31);

		ROR(W0, 31);
		for (int i = 0; i < 16; i++)
			w[i + 112] = W0[i] ^ W3[i];
		ROL(W0, 31);

		ROL(W1, 61);
		for (int i = 0; i < 16; i++)
			w[i + 128] = W0[i] ^ W1[i];
		ROR(W1, 61);

		ROL(W2, 61);
		for (int i = 0; i < 16; i++)
			w[i + 144] = W1[i] ^ W2[i];
		ROR(W2, 61);

		ROL(W3, 61);
		for (int i = 0; i < 16; i++)
			w[i + 160] = W2[i] ^ W3[i];
		ROR(W3, 61);

		ROL(W0, 61);
		for (int i = 0; i < 16; i++)
			w[i + 176] = W0[i] ^ W3[i];
		ROR(W0, 61);

		ROL(W1, 31);
		for (int i = 0; i < 16; i++)
			w[i + 192] = W0[i] ^ W1[i];
		ROR(W1, 31);

		ROL(W2, 31);
		for (int i = 0; i < 16; i++)
			w[i + 208] = W1[i] ^ W2[i];
		ROR(W2, 31);

		ROL(W3, 31);
		for (int i = 0; i < 16; i++)
			w[i + 224] = W2[i] ^ W3[i];
		ROR(W3, 31);

	}
	else {
		byte KL[16] = { 0x00 ,0x01 ,0x02 ,0x03 ,0x04 ,0x05 ,0x06 ,0x07 ,0x08 ,0x09 ,0x0a ,0x0b ,0x0c ,0x0d ,0x0e, 0x0f };
		byte KR[16] = { 0x10 ,0x11 ,0x12 ,0x13 ,0x14 ,0x15 ,0x16 ,0x17 ,0x18 ,0x19 ,0x1a ,0x1b ,0x1c ,0x1d ,0x1e ,0x1f };
		byte ck1[16] = { 0xdb, 0x92, 0x37, 0x1d, 0x21, 0x26, 0xe9, 0x70, 0x03, 0x24, 0x97, 0x75, 0x04, 0xe8, 0xc9, 0x0e };
		byte ck2[16] = { 0x51, 0x7c, 0xc1, 0xb7, 0x27, 0x22, 0x0a, 0x94, 0xfe, 0x13, 0xab, 0xe8, 0xfa, 0x9a, 0x6e, 0xe0 };
		byte ck3[16] = { 0x6d, 0xb1, 0x4a, 0xcc, 0x9e, 0x21, 0xc8, 0x20, 0xff, 0x28, 0xb1, 0xd5, 0xef, 0x5d, 0xe2, 0xb0 };

		memcpy(W0, KL, 16);
		memcpy(tmp, W0, 16);
		F_o(tmp, ck1);
		for (int i = 0; i < 16; i++)
			W1[i] = tmp[i] ^ KR[i];
		memcpy(tmp, W1, 16);
		F_e(tmp, ck2);
		for (int i = 0; i < 16; i++)
			W2[i] = tmp[i] ^ W0[i];
		memcpy(tmp, W2, 16);
		F_o(tmp, ck3);
		for (int i = 0; i < 16; i++)
			W3[i] = tmp[i] ^ W1[i];

		ROR(W1, 19);
		for (int i = 0; i < 16; i++)
			w[i] = W0[i] ^ W1[i];
		ROL(W1, 19);

		ROR(W2, 19);
		for (int i = 0; i < 16; i++)
			w[i + 16] = W1[i] ^ W2[i];
		ROL(W2, 19);

		ROR(W3, 19);
		for (int i = 0; i < 16; i++)
			w[i + 32] = W2[i] ^ W3[i];
		ROL(W3, 19);

		ROR(W0, 19);
		for (int i = 0; i < 16; i++)
			w[i + 48] = W0[i] ^ W3[i];
		ROL(W0, 19);

		ROR(W1, 31);
		for (int i = 0; i < 16; i++)
			w[i + 64] = W0[i] ^ W1[i];
		ROL(W1, 31);

		ROR(W2, 31);
		for (int i = 0; i < 16; i++)
			w[i + 80] = W1[i] ^ W2[i];
		ROL(W2, 31);

		ROR(W3, 31);
		for (int i = 0; i < 16; i++)
			w[i + 96] = W2[i] ^ W3[i];
		ROL(W3, 31);

		ROR(W0, 31);
		for (int i = 0; i < 16; i++)
			w[i + 112] = W0[i] ^ W3[i];
		ROL(W0, 31);

		ROL(W1, 61);
		for (int i = 0; i < 16; i++)
			w[i + 128] = W0[i] ^ W1[i];
		ROR(W1, 61);

		ROL(W2, 61);
		for (int i = 0; i < 16; i++)
			w[i + 144] = W1[i] ^ W2[i];
		ROR(W2, 61);

		ROL(W3, 61);
		for (int i = 0; i < 16; i++)
			w[i + 160] = W2[i] ^ W3[i];
		ROR(W3, 61);

		ROL(W0, 61);
		for (int i = 0; i < 16; i++)
			w[i + 176] = W0[i] ^ W3[i];
		ROR(W0, 61);

		ROL(W1, 31);
		for (int i = 0; i < 16; i++)
			w[i + 192] = W0[i] ^ W1[i];
		ROR(W1, 31);

		ROL(W2, 31);
		for (int i = 0; i < 16; i++)
			w[i + 208] = W1[i] ^ W2[i];
		ROR(W2, 31);

		ROL(W3, 31);
		for (int i = 0; i < 16; i++)
			w[i + 224] = W2[i] ^ W3[i];
		ROR(W3, 31);

		ROL(W0, 31);
		for (int i = 0; i < 16; i++)
			w[i + 240] = W0[i] ^ W3[i];
		ROR(W0, 31);

		ROL(W1, 19);
		for (int i = 0; i < 16; i++)
			w[i + 256] = W0[i] ^ W1[i];
		ROR(W1, 19);
	}

}


void aria_enc(byte* state, byte* out, byte* key, unsigned int keyLen) {

	if (keyLen == 16) {
		//byte aria_w[16 * (12 + 1)] = { 0x00 };
		int i = 0;
		//Key_expansion(aria_w, key,keyLen);

		for (i = 0; i < 12 - 1; i++) {
			if ((i % 2) == 0)
				F_o(state, (key + (i * 16)));
			else {
				F_e(state, (key + (i * 16)));
			}
		}
		Add_Round_Key(state, (key + ((i)*16)));
		SubstLayer(state, 1);
		Add_Round_Key(state, (key + ((i + 1) * 16)));

		memcpy(out, state, 16);
	}
	else if (keyLen == 24) {
		//byte aria_w[16 * (14 + 1)] = { 0x00 };
		int i = 0;
		//Key_expansion(aria_w, key,keyLen);

		for (i = 0; i < 14 - 1; i++) {
			if ((i % 2) == 0)
				F_o(state, (key + (i * 16)));
			else {
				F_e(state, (key + (i * 16)));
			}
		}
		Add_Round_Key(state, (key + ((i) * 16)));
		SubstLayer(state, 1);
		Add_Round_Key(state, (key + ((i + 1) * 16)));

		memcpy(out, state, 16);
	}
	else {
		//byte aria_w[16 * (16 + 1)] = { 0x00 };
		int i = 0;
		//Key_expansion(aria_w, key,keyLen);

		for (i = 0; i < 16 - 1; i++) {
			if ((i % 2) == 0)
				F_o(state, (key + (i * 16)));
			else {
				F_e(state, (key + (i * 16)));
			}
		}
		Add_Round_Key(state, (key + ((i) * 16)));
		SubstLayer(state, 1);
		Add_Round_Key(state, (key + ((i + 1) * 16)));

		memcpy(out, state, 16);
	}
}

void aria_dec(byte* state, byte* out, byte* key, unsigned int keyLen) {
	if (keyLen == 16) {
		byte aria_w[16 * (12 + 1)] = { 0x00 };
		int i = 0;
		Key_expansion(aria_w, key,keyLen);
		F_o(state, (aria_w + (16 * 12) - (i * 16)));
		for (i = 1; i < 12 - 1; i++) {
			if ((i % 2) == 0) {
				DiffLayer(aria_w + (16 * 12) - (i * 16));
				F_o(state, (aria_w + (16 * 12) - (i * 16)));
			}
			else {
				DiffLayer(aria_w + (16 * 12) - (i * 16));
				F_e(state, (aria_w + (16 * 12) - (i * 16)));
			}

		}
		DiffLayer(aria_w + (16 * 12) - (i * 16));
		Add_Round_Key(state, (aria_w + (16 * 12) - (i * 16)));
		SubstLayer(state, 1);
		Add_Round_Key(state, (aria_w + (16 * 12) - ((i + 1) * 16)));

		memcpy(out, state, 16);
	}
	else if (keyLen == 24) {
		byte aria_w[16 * (14 + 1)] = { 0x00 };
		int i = 0;
		Key_expansion(aria_w, key, keyLen);
		F_o(state, (aria_w + (16 * 14) - (i * 16)));
		for (i = 1; i < 14 - 1; i++) {
			if ((i % 2) == 0) {
				DiffLayer(aria_w + (16 * 14) - (i * 16));
				F_o(state, (aria_w + (16 * 14) - (i * 16)));
			}
			else {
				DiffLayer(aria_w + (16 * 14) - (i * 16));
				F_e(state, (aria_w + (16 * 14) - (i * 16)));
			}

		}
		DiffLayer(aria_w + (16 * 14) - (i * 16));
		Add_Round_Key(state, (aria_w + (16 * 14) - (i * 16)));
		SubstLayer(state, 1);
		Add_Round_Key(state, (aria_w + (16 * 14) - ((i + 1) * 16)));

		memcpy(out, state, 16);
	}
	else {
		byte aria_w[16 * (16 + 1)] = { 0x00 };
		int i = 0;
		Key_expansion(aria_w, key, keyLen);
		F_o(state, (aria_w + (16 * 16) - (i * 16)));
		for (i = 1; i < 16 - 1; i++) {
			if ((i % 2) == 0) {
				DiffLayer(aria_w + (16 * 16) - (i * 16));
				F_o(state, (aria_w + (16 * 16) - (i * 16)));
			}
			else {
				DiffLayer(aria_w + (16 * 16) - (i * 16));
				F_e(state, (aria_w + (16 * 16) - (i * 16)));
			}

		}
		DiffLayer(aria_w + (16 * 16) - (i * 16));
		Add_Round_Key(state, (aria_w + (16 * 16) - (i * 16)));
		SubstLayer(state, 1);
		Add_Round_Key(state, (aria_w + (16 * 16) - ((i + 1) * 16)));

		memcpy(out, state, 16);
	}

}

